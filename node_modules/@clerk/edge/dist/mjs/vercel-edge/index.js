import { AuthStatus, Base, createGetToken, createSignedOutState } from '@clerk/backend-core';
import { ClerkAPI } from './ClerkAPI';
import { injectAuthIntoRequest } from './utils/injectAuthIntoRequest';
import { interstitialResponse, signedOutResponse } from './utils/responses';
const importKey = async (jwk, algorithm) => {
    return await crypto.subtle.importKey('jwk', jwk, algorithm, true, ['verify']);
};
const verifySignature = async (algorithm, key, signature, data) => {
    return await crypto.subtle.verify(algorithm, key, signature, data);
};
const decodeBase64 = (base64) => atob(base64);
const vercelEdgeBase = new Base(importKey, verifySignature, decodeBase64);
export const verifySessionToken = vercelEdgeBase.verifySessionToken;
const allowlistIdentifiers = ClerkAPI.allowlistIdentifiers;
const clients = ClerkAPI.clients;
const emails = ClerkAPI.emails;
const invitations = ClerkAPI.invitations;
const organizations = ClerkAPI.organizations;
const sessions = ClerkAPI.sessions;
const smsMessages = ClerkAPI.smsMessages;
const users = ClerkAPI.users;
export { allowlistIdentifiers, clients, emails, invitations, organizations, sessions, smsMessages, users };
async function fetchInterstitial() {
    return ClerkAPI.fetchInterstitial();
}
export function withEdgeMiddlewareAuth(handler, options = {
    loadSession: false,
    loadUser: false,
    strict: false,
}) {
    return vercelMiddlewareAuth(handler, { strict: false, ...options });
}
export function requireEdgeMiddlewareAuth(handler, options = {
    loadSession: false,
    loadUser: false,
}) {
    return vercelMiddlewareAuth(handler, { strict: true, ...options });
}
function vercelMiddlewareAuth(handler, options = {
    loadSession: false,
    loadUser: false,
}) {
    return async function clerkAuth(req, event) {
        const { loadUser, loadSession, jwtKey, authorizedParties } = options;
        const cookieToken = getCookie(req.cookies, '__session');
        const clientUat = getCookie(req.cookies, '__client_uat');
        const headerToken = req.headers.get('authorization');
        const { status, interstitial, sessionClaims, errorReason } = await vercelEdgeBase.getAuthState({
            cookieToken,
            headerToken,
            clientUat,
            origin: req.headers.get('origin'),
            host: req.headers.get('host'),
            userAgent: req.headers.get('user-agent'),
            forwardedPort: req.headers.get('x-forwarded-port'),
            forwardedHost: req.headers.get('x-forwarded-host'),
            referrer: req.headers.get('referrer'),
            authorizedParties,
            jwtKey,
            fetchInterstitial,
        });
        if (status === AuthStatus.Interstitial) {
            return interstitialResponse(interstitial, errorReason);
        }
        if (status === AuthStatus.SignedOut) {
            if (options.strict) {
                return signedOutResponse(errorReason);
            }
            const response = (await handler(injectAuthIntoRequest(req, createSignedOutState()), event));
            response?.headers.set('Auth-Result', errorReason || '');
            return response;
        }
        const sessionId = sessionClaims.sid;
        const userId = sessionClaims.sub;
        const [user, session] = await Promise.all([
            loadUser ? ClerkAPI.users.getUser(userId) : Promise.resolve(undefined),
            loadSession ? ClerkAPI.sessions.getSession(sessionId) : Promise.resolve(undefined),
        ]);
        const getToken = createGetToken({
            sessionId,
            cookieToken,
            headerToken: headerToken || '',
            fetcher: (...args) => ClerkAPI.sessions.getToken(...args),
        });
        const authRequest = injectAuthIntoRequest(req, {
            user,
            session,
            sessionId,
            userId,
            getToken,
            claims: sessionClaims,
        });
        return handler(authRequest, event);
    };
}
function getCookie(cookies, name) {
    if (typeof cookies.get === 'function') {
        return cookies.get(name);
    }
    else {
        return cookies[name];
    }
}
