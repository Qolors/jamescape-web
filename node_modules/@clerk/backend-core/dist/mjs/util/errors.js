import { AuthErrorReason, TokenVerificationErrorReason } from '../types';
export class TokenVerificationError extends Error {
    constructor(reason) {
        super();
        this.reason = reason;
    }
}
export function mapErrorReasonResponse(reason, tokenType) {
    let errorReason = AuthErrorReason.InternalError;
    let shouldSignout = true;
    const isCookieToken = tokenType === 'cookie';
    switch (+reason) {
        case TokenVerificationErrorReason.Expired:
            errorReason = isCookieToken ? AuthErrorReason.CookieExpired : AuthErrorReason.HeaderExpired;
            shouldSignout = false;
            break;
        case TokenVerificationErrorReason.Invalid:
            errorReason = isCookieToken ? AuthErrorReason.CookieInvalid : AuthErrorReason.HeaderInvalid;
            break;
        case TokenVerificationErrorReason.InvalidIssuer:
            errorReason = isCookieToken ? AuthErrorReason.CookieInvalidIssuer : AuthErrorReason.HeaderInvalidIssuer;
            break;
        case TokenVerificationErrorReason.JWTKeyMissing:
            errorReason = AuthErrorReason.InlineKeyMissing;
            break;
        case TokenVerificationErrorReason.MalformedToken:
            errorReason = isCookieToken ? AuthErrorReason.CookieInvalid : AuthErrorReason.HeaderInvalid;
            break;
        case TokenVerificationErrorReason.NotActiveYet:
            errorReason = isCookieToken ? AuthErrorReason.CookieEarly : AuthErrorReason.HeaderEarly;
            shouldSignout = false;
            break;
        case TokenVerificationErrorReason.UnauthorizedParty:
            errorReason = isCookieToken ? AuthErrorReason.CookieUnauthorizedParty : AuthErrorReason.HeaderUnauthorizedParty;
            break;
        case TokenVerificationErrorReason.VerificationFailed:
            errorReason = isCookieToken ? AuthErrorReason.CookieVerificationFailed : AuthErrorReason.HeaderVerificationFailed;
            break;
        case TokenVerificationErrorReason.PublicKeyFetchError:
            errorReason = AuthErrorReason.PublicKeyFetchError;
            break;
        case TokenVerificationErrorReason.ImportKeyError:
            errorReason = AuthErrorReason.InlineKeyInvalid;
    }
    return { errorReason, shouldSignout };
}
