import { AuthErrorReason, AuthStatus, TokenVerificationErrorReason, } from './types';
import { parse } from './util/base64url';
import { isDevelopmentOrStaging, isProduction } from './util/clerkApiKey';
import { mapErrorReasonResponse, TokenVerificationError } from './util/errors';
import { checkClaims, isExpired } from './util/jwt';
import { checkCrossOrigin } from './util/request';
export const API_KEY = process.env.CLERK_API_KEY || '';
export class Base {
    constructor(importKeyFunction, verifySignatureFunction, decodeBase64Function, loadCryptoKeyFunction) {
        this.verifySessionToken = async (token, { authorizedParties, jwtKey } = {}) => {
            let availableKey;
            if (!jwtKey && this.loadCryptoKeyFunction) {
                try {
                    availableKey = await this.loadCryptoKeyFunction(token);
                }
                catch (_) {
                    throw new TokenVerificationError(TokenVerificationErrorReason.PublicKeyFetchError);
                }
            }
            else {
                availableKey = await this.loadCryptoKey(jwtKey || process.env.CLERK_JWT_KEY);
            }
            const claims = await this.verifyJwt(availableKey, token);
            checkClaims(claims, authorizedParties);
            return claims;
        };
        this.loadCryptoKey = async (key) => {
            if (!key) {
                throw new TokenVerificationError(TokenVerificationErrorReason.JWTKeyMissing);
            }
            const RSA_PREFIX = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA';
            const RSA_SUFFIX = 'IDAQAB';
            const jwk = {
                kty: 'RSA',
                n: key
                    .slice(RSA_PREFIX.length, RSA_SUFFIX.length * -1)
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_'),
                e: 'AQAB',
            };
            const algorithm = {
                name: 'RSASSA-PKCS1-v1_5',
                hash: 'SHA-256',
            };
            try {
                return this.importKeyFunction(jwk, algorithm);
            }
            catch (_) {
                throw new TokenVerificationError(TokenVerificationErrorReason.ImportKeyError);
            }
        };
        this.decodeJwt = (token) => {
            const tokenParts = token.split('.');
            if (tokenParts.length !== 3) {
                throw new TokenVerificationError(TokenVerificationErrorReason.MalformedToken);
            }
            const [rawHeader, rawPayload, rawSignature] = tokenParts;
            const header = JSON.parse(this.decodeBase64Function(rawHeader));
            const payload = JSON.parse(this.decodeBase64Function(rawPayload));
            const signature = this.decodeBase64Function(rawSignature.replace(/_/g, '/').replace(/-/g, '+'));
            return {
                header,
                payload,
                signature,
            };
        };
        this.verifyJwtSignature = async (key, token) => {
            const [rawHeader, rawPayload, rawSignature] = token.split('.');
            const encoder = new TextEncoder();
            const data = encoder.encode([rawHeader, rawPayload].join('.'));
            const signature = parse(rawSignature);
            const isVerified = await this.verifySignatureFunction('RSASSA-PKCS1-v1_5', key, signature, data);
            if (!isVerified) {
                throw new TokenVerificationError(TokenVerificationErrorReason.VerificationFailed);
            }
        };
        this.verifyJwt = async (key, token) => {
            const { payload } = this.decodeJwt(token);
            await this.verifyJwtSignature(key, token);
            isExpired(payload);
            return payload;
        };
        this.getAuthState = async ({ cookieToken, clientUat, headerToken, origin, host, forwardedHost, forwardedPort, forwardedProto, referrer, userAgent, authorizedParties, fetchInterstitial, jwtKey, }) => {
            if (headerToken) {
                return this.buildAuthenticatedState(headerToken, {
                    jwtKey,
                    authorizedParties,
                    fetchInterstitial,
                    tokenType: 'header',
                });
            }
            const isDevelopmentKey = isDevelopmentOrStaging(API_KEY);
            const isProductionKey = isProduction(API_KEY);
            if (isDevelopmentKey && !userAgent?.startsWith('Mozilla/')) {
                return { status: AuthStatus.SignedOut, errorReason: AuthErrorReason.HeaderMissingNonBrowser };
            }
            if (origin &&
                checkCrossOrigin({
                    originURL: new URL(origin),
                    host,
                    forwardedHost,
                    forwardedPort,
                    forwardedProto,
                })) {
                return { status: AuthStatus.SignedOut, errorReason: AuthErrorReason.HeaderMissingCORS };
            }
            if (isDevelopmentKey && !clientUat) {
                return {
                    status: AuthStatus.Interstitial,
                    interstitial: await fetchInterstitial(),
                    errorReason: AuthErrorReason.UATMissing,
                };
            }
            if (isDevelopmentKey &&
                referrer &&
                checkCrossOrigin({
                    originURL: new URL(referrer),
                    host,
                    forwardedHost,
                    forwardedPort,
                    forwardedProto,
                })) {
                return {
                    status: AuthStatus.Interstitial,
                    interstitial: await fetchInterstitial(),
                    errorReason: AuthErrorReason.CrossOriginReferrer,
                };
            }
            if (isProductionKey && !clientUat && !cookieToken) {
                return { status: AuthStatus.SignedOut, errorReason: AuthErrorReason.CookieAndUATMissing };
            }
            if (clientUat === '0') {
                return { status: AuthStatus.SignedOut, errorReason: AuthErrorReason.StandardOut };
            }
            if (isProductionKey && clientUat && !cookieToken) {
                return {
                    status: AuthStatus.Interstitial,
                    interstitial: await fetchInterstitial(),
                    errorReason: AuthErrorReason.CookieMissing,
                };
            }
            const authenticatedState = await this.buildAuthenticatedState(cookieToken, {
                jwtKey,
                authorizedParties,
                fetchInterstitial,
                tokenType: 'cookie',
            });
            if (authenticatedState.sessionClaims && authenticatedState.sessionClaims.iat >= Number(clientUat)) {
                return authenticatedState;
            }
            else if (authenticatedState.sessionClaims && authenticatedState.sessionClaims.iat < Number(clientUat)) {
                return {
                    status: AuthStatus.Interstitial,
                    interstitial: await fetchInterstitial(),
                    errorReason: AuthErrorReason.CookieOutDated,
                };
            }
            else if (!authenticatedState.sessionClaims) {
                return authenticatedState;
            }
            return {
                status: AuthStatus.Interstitial,
                interstitial: await fetchInterstitial(),
                errorReason: AuthErrorReason.Unknown,
            };
        };
        this.buildAuthenticatedState = async (token, { authorizedParties, jwtKey, fetchInterstitial, tokenType }) => {
            try {
                const sessionClaims = await this.verifySessionToken(token, {
                    authorizedParties,
                    jwtKey,
                });
                return {
                    status: AuthStatus.SignedIn,
                    session: {
                        id: sessionClaims.sid,
                        userId: sessionClaims.sub,
                    },
                    sessionClaims,
                };
            }
            catch (err) {
                if (err instanceof TokenVerificationError) {
                    const { errorReason, shouldSignout } = mapErrorReasonResponse(err.reason, tokenType);
                    if (shouldSignout) {
                        return { status: AuthStatus.SignedOut, errorReason };
                    }
                    return {
                        status: AuthStatus.Interstitial,
                        interstitial: await fetchInterstitial(),
                        errorReason,
                    };
                }
                return { status: AuthStatus.SignedOut, errorReason: AuthErrorReason.InternalError };
            }
        };
        this.importKeyFunction = importKeyFunction;
        this.verifySignatureFunction = verifySignatureFunction;
        this.decodeBase64Function = decodeBase64Function;
        this.loadCryptoKeyFunction = loadCryptoKeyFunction;
    }
}
