"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapErrorReasonResponse = exports.TokenVerificationError = void 0;
const types_1 = require("../types");
class TokenVerificationError extends Error {
    constructor(reason) {
        super();
        this.reason = reason;
    }
}
exports.TokenVerificationError = TokenVerificationError;
function mapErrorReasonResponse(reason, tokenType) {
    let errorReason = types_1.AuthErrorReason.InternalError;
    let shouldSignout = true;
    const isCookieToken = tokenType === 'cookie';
    switch (+reason) {
        case types_1.TokenVerificationErrorReason.Expired:
            errorReason = isCookieToken ? types_1.AuthErrorReason.CookieExpired : types_1.AuthErrorReason.HeaderExpired;
            shouldSignout = false;
            break;
        case types_1.TokenVerificationErrorReason.Invalid:
            errorReason = isCookieToken ? types_1.AuthErrorReason.CookieInvalid : types_1.AuthErrorReason.HeaderInvalid;
            break;
        case types_1.TokenVerificationErrorReason.InvalidIssuer:
            errorReason = isCookieToken ? types_1.AuthErrorReason.CookieInvalidIssuer : types_1.AuthErrorReason.HeaderInvalidIssuer;
            break;
        case types_1.TokenVerificationErrorReason.JWTKeyMissing:
            errorReason = types_1.AuthErrorReason.InlineKeyMissing;
            break;
        case types_1.TokenVerificationErrorReason.MalformedToken:
            errorReason = isCookieToken ? types_1.AuthErrorReason.CookieInvalid : types_1.AuthErrorReason.HeaderInvalid;
            break;
        case types_1.TokenVerificationErrorReason.NotActiveYet:
            errorReason = isCookieToken ? types_1.AuthErrorReason.CookieEarly : types_1.AuthErrorReason.HeaderEarly;
            shouldSignout = false;
            break;
        case types_1.TokenVerificationErrorReason.UnauthorizedParty:
            errorReason = isCookieToken ? types_1.AuthErrorReason.CookieUnauthorizedParty : types_1.AuthErrorReason.HeaderUnauthorizedParty;
            break;
        case types_1.TokenVerificationErrorReason.VerificationFailed:
            errorReason = isCookieToken ? types_1.AuthErrorReason.CookieVerificationFailed : types_1.AuthErrorReason.HeaderVerificationFailed;
            break;
        case types_1.TokenVerificationErrorReason.PublicKeyFetchError:
            errorReason = types_1.AuthErrorReason.PublicKeyFetchError;
            break;
        case types_1.TokenVerificationErrorReason.ImportKeyError:
            errorReason = types_1.AuthErrorReason.InlineKeyInvalid;
    }
    return { errorReason, shouldSignout };
}
exports.mapErrorReasonResponse = mapErrorReasonResponse;
