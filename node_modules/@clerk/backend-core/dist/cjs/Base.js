"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Base = exports.API_KEY = void 0;
const types_1 = require("./types");
const base64url_1 = require("./util/base64url");
const clerkApiKey_1 = require("./util/clerkApiKey");
const errors_1 = require("./util/errors");
const jwt_1 = require("./util/jwt");
const request_1 = require("./util/request");
exports.API_KEY = process.env.CLERK_API_KEY || '';
class Base {
    constructor(importKeyFunction, verifySignatureFunction, decodeBase64Function, loadCryptoKeyFunction) {
        this.verifySessionToken = async (token, { authorizedParties, jwtKey } = {}) => {
            let availableKey;
            if (!jwtKey && this.loadCryptoKeyFunction) {
                try {
                    availableKey = await this.loadCryptoKeyFunction(token);
                }
                catch (_) {
                    throw new errors_1.TokenVerificationError(types_1.TokenVerificationErrorReason.PublicKeyFetchError);
                }
            }
            else {
                availableKey = await this.loadCryptoKey(jwtKey || process.env.CLERK_JWT_KEY);
            }
            const claims = await this.verifyJwt(availableKey, token);
            (0, jwt_1.checkClaims)(claims, authorizedParties);
            return claims;
        };
        this.loadCryptoKey = async (key) => {
            if (!key) {
                throw new errors_1.TokenVerificationError(types_1.TokenVerificationErrorReason.JWTKeyMissing);
            }
            const RSA_PREFIX = 'MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA';
            const RSA_SUFFIX = 'IDAQAB';
            const jwk = {
                kty: 'RSA',
                n: key
                    .slice(RSA_PREFIX.length, RSA_SUFFIX.length * -1)
                    .replace(/\+/g, '-')
                    .replace(/\//g, '_'),
                e: 'AQAB',
            };
            const algorithm = {
                name: 'RSASSA-PKCS1-v1_5',
                hash: 'SHA-256',
            };
            try {
                return this.importKeyFunction(jwk, algorithm);
            }
            catch (_) {
                throw new errors_1.TokenVerificationError(types_1.TokenVerificationErrorReason.ImportKeyError);
            }
        };
        this.decodeJwt = (token) => {
            const tokenParts = token.split('.');
            if (tokenParts.length !== 3) {
                throw new errors_1.TokenVerificationError(types_1.TokenVerificationErrorReason.MalformedToken);
            }
            const [rawHeader, rawPayload, rawSignature] = tokenParts;
            const header = JSON.parse(this.decodeBase64Function(rawHeader));
            const payload = JSON.parse(this.decodeBase64Function(rawPayload));
            const signature = this.decodeBase64Function(rawSignature.replace(/_/g, '/').replace(/-/g, '+'));
            return {
                header,
                payload,
                signature,
            };
        };
        this.verifyJwtSignature = async (key, token) => {
            const [rawHeader, rawPayload, rawSignature] = token.split('.');
            const encoder = new TextEncoder();
            const data = encoder.encode([rawHeader, rawPayload].join('.'));
            const signature = (0, base64url_1.parse)(rawSignature);
            const isVerified = await this.verifySignatureFunction('RSASSA-PKCS1-v1_5', key, signature, data);
            if (!isVerified) {
                throw new errors_1.TokenVerificationError(types_1.TokenVerificationErrorReason.VerificationFailed);
            }
        };
        this.verifyJwt = async (key, token) => {
            const { payload } = this.decodeJwt(token);
            await this.verifyJwtSignature(key, token);
            (0, jwt_1.isExpired)(payload);
            return payload;
        };
        this.getAuthState = async ({ cookieToken, clientUat, headerToken, origin, host, forwardedHost, forwardedPort, forwardedProto, referrer, userAgent, authorizedParties, fetchInterstitial, jwtKey, }) => {
            if (headerToken) {
                return this.buildAuthenticatedState(headerToken, {
                    jwtKey,
                    authorizedParties,
                    fetchInterstitial,
                    tokenType: 'header',
                });
            }
            const isDevelopmentKey = (0, clerkApiKey_1.isDevelopmentOrStaging)(exports.API_KEY);
            const isProductionKey = (0, clerkApiKey_1.isProduction)(exports.API_KEY);
            if (isDevelopmentKey && !(userAgent === null || userAgent === void 0 ? void 0 : userAgent.startsWith('Mozilla/'))) {
                return { status: types_1.AuthStatus.SignedOut, errorReason: types_1.AuthErrorReason.HeaderMissingNonBrowser };
            }
            if (origin &&
                (0, request_1.checkCrossOrigin)({
                    originURL: new URL(origin),
                    host,
                    forwardedHost,
                    forwardedPort,
                    forwardedProto,
                })) {
                return { status: types_1.AuthStatus.SignedOut, errorReason: types_1.AuthErrorReason.HeaderMissingCORS };
            }
            if (isDevelopmentKey && !clientUat) {
                return {
                    status: types_1.AuthStatus.Interstitial,
                    interstitial: await fetchInterstitial(),
                    errorReason: types_1.AuthErrorReason.UATMissing,
                };
            }
            if (isDevelopmentKey &&
                referrer &&
                (0, request_1.checkCrossOrigin)({
                    originURL: new URL(referrer),
                    host,
                    forwardedHost,
                    forwardedPort,
                    forwardedProto,
                })) {
                return {
                    status: types_1.AuthStatus.Interstitial,
                    interstitial: await fetchInterstitial(),
                    errorReason: types_1.AuthErrorReason.CrossOriginReferrer,
                };
            }
            if (isProductionKey && !clientUat && !cookieToken) {
                return { status: types_1.AuthStatus.SignedOut, errorReason: types_1.AuthErrorReason.CookieAndUATMissing };
            }
            if (clientUat === '0') {
                return { status: types_1.AuthStatus.SignedOut, errorReason: types_1.AuthErrorReason.StandardOut };
            }
            if (isProductionKey && clientUat && !cookieToken) {
                return {
                    status: types_1.AuthStatus.Interstitial,
                    interstitial: await fetchInterstitial(),
                    errorReason: types_1.AuthErrorReason.CookieMissing,
                };
            }
            const authenticatedState = await this.buildAuthenticatedState(cookieToken, {
                jwtKey,
                authorizedParties,
                fetchInterstitial,
                tokenType: 'cookie',
            });
            if (authenticatedState.sessionClaims && authenticatedState.sessionClaims.iat >= Number(clientUat)) {
                return authenticatedState;
            }
            else if (authenticatedState.sessionClaims && authenticatedState.sessionClaims.iat < Number(clientUat)) {
                return {
                    status: types_1.AuthStatus.Interstitial,
                    interstitial: await fetchInterstitial(),
                    errorReason: types_1.AuthErrorReason.CookieOutDated,
                };
            }
            else if (!authenticatedState.sessionClaims) {
                return authenticatedState;
            }
            return {
                status: types_1.AuthStatus.Interstitial,
                interstitial: await fetchInterstitial(),
                errorReason: types_1.AuthErrorReason.Unknown,
            };
        };
        this.buildAuthenticatedState = async (token, { authorizedParties, jwtKey, fetchInterstitial, tokenType }) => {
            try {
                const sessionClaims = await this.verifySessionToken(token, {
                    authorizedParties,
                    jwtKey,
                });
                return {
                    status: types_1.AuthStatus.SignedIn,
                    session: {
                        id: sessionClaims.sid,
                        userId: sessionClaims.sub,
                    },
                    sessionClaims,
                };
            }
            catch (err) {
                if (err instanceof errors_1.TokenVerificationError) {
                    const { errorReason, shouldSignout } = (0, errors_1.mapErrorReasonResponse)(err.reason, tokenType);
                    if (shouldSignout) {
                        return { status: types_1.AuthStatus.SignedOut, errorReason };
                    }
                    return {
                        status: types_1.AuthStatus.Interstitial,
                        interstitial: await fetchInterstitial(),
                        errorReason,
                    };
                }
                return { status: types_1.AuthStatus.SignedOut, errorReason: types_1.AuthErrorReason.InternalError };
            }
        };
        this.importKeyFunction = importKeyFunction;
        this.verifySignatureFunction = verifySignatureFunction;
        this.decodeBase64Function = decodeBase64Function;
        this.loadCryptoKeyFunction = loadCryptoKeyFunction;
    }
}
exports.Base = Base;
