"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const backend_core_1 = require("@clerk/backend-core");
const cookies_1 = tslib_1.__importDefault(require("cookies"));
const deepmerge_1 = tslib_1.__importDefault(require("deepmerge"));
const jsonwebtoken_1 = tslib_1.__importDefault(require("jsonwebtoken"));
const jwks_rsa_1 = tslib_1.__importDefault(require("jwks-rsa"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const SupportMessages_1 = require("./constants/SupportMessages");
const info_1 = require("./info");
const utils_1 = require("./utils");
const defaultApiKey = process.env.CLERK_API_KEY || '';
const defaultJWTKey = process.env.CLERK_JWT_KEY;
const defaultApiVersion = process.env.CLERK_API_VERSION || 'v1';
const defaultServerApiUrl = process.env.CLERK_API_URL || 'https://api.clerk.dev';
const JWKS_MAX_AGE = 3600000; // 1 hour
class Clerk extends backend_core_1.ClerkBackendAPI {
    constructor({ apiKey = defaultApiKey, jwtKey = defaultJWTKey, apiUrl = defaultServerApiUrl, apiVersion = defaultApiVersion, httpOptions = {}, jwksCacheMaxAge = JWKS_MAX_AGE, } = {}) {
        super({
            apiKey,
            apiVersion,
            apiUrl,
            libName: info_1.LIB_NAME,
            libVersion: info_1.LIB_VERSION,
            apiClient: {
                async request(options) {
                    const { url, method, queryParams, headerParams, bodyParams } = options;
                    // Build final URL with search parameters
                    const finalUrl = new URL(url || '');
                    if (queryParams) {
                        for (const [key, val] of Object.entries(queryParams)) {
                            // Support array values for queryParams such as { foo: [42, 43] }
                            if (val) {
                                [val]
                                    .flat()
                                    .forEach((v) => finalUrl.searchParams.append(key, v));
                            }
                        }
                    }
                    const response = await (0, node_fetch_1.default)(finalUrl.href, (0, deepmerge_1.default)(httpOptions, {
                        method,
                        headers: headerParams,
                        ...(bodyParams &&
                            Object.keys(bodyParams).length > 0 && {
                            body: JSON.stringify(bodyParams),
                        }),
                    }));
                    // Parse JSON or Text response.
                    const isJSONResponse = headerParams && headerParams['Content-Type'] === 'application/json';
                    const data = (await (isJSONResponse
                        ? response.json()
                        : response.text()));
                    // Check for errors
                    if (!response.ok) {
                        throw new backend_core_1.ClerkAPIResponseError(response.statusText, {
                            data: data?.errors || data,
                            status: response.status,
                        });
                    }
                    return data;
                },
            },
        });
        if (!apiKey) {
            throw Error(SupportMessages_1.SupportMessages.API_KEY_NOT_FOUND);
        }
        this.httpOptions = httpOptions;
        this.jwtKey = jwtKey;
        this._jwksClient = (0, jwks_rsa_1.default)({
            jwksUri: `${apiUrl}/${apiVersion}/jwks`,
            requestHeaders: {
                Authorization: `Bearer ${apiKey}`,
            },
            timeout: 5000,
            cache: true,
            cacheMaxAge: jwksCacheMaxAge,
        });
        const loadCryptoKey = async (token) => {
            const decoded = jsonwebtoken_1.default.decode(token, { complete: true });
            if (!decoded) {
                throw new Error(`Failed to decode token: ${token}`);
            }
            const signingKey = await this._jwksClient.getSigningKey(decoded.header.kid);
            const publicKey = signingKey.getPublicKey();
            return (0, utils_1.importPKIKey)(publicKey);
        };
        /** Base initialization */
        // TODO: More comprehensive base initialization
        this.base = new backend_core_1.Base(utils_1.importJSONWebKey, utils_1.verifySignature, utils_1.decodeBase64, loadCryptoKey);
    }
    async verifyToken(token, authorizedParties) {
        const decoded = jsonwebtoken_1.default.decode(token, { complete: true });
        if (!decoded) {
            throw new Error(`Failed to verify token: ${token}`);
        }
        const key = await this._jwksClient.getSigningKey(decoded.header.kid);
        const verified = jsonwebtoken_1.default.verify(token, key.getPublicKey(), {
            algorithms: ['RS256'],
        });
        if (typeof verified === 'string') {
            throw new Error('Malformed token');
        }
        if (!verified.iss || !verified.iss.startsWith('https://clerk')) {
            throw new Error(`Issuer is invalid: ${verified.iss}`);
        }
        if (verified.azp && authorizedParties && authorizedParties.length > 0) {
            if (!authorizedParties.includes(verified.azp)) {
                throw new Error(`Authorized party is invalid: ${verified.azp}`);
            }
        }
        return verified;
    }
    // For use as singleton, always returns the same instance
    static getInstance() {
        if (!this._instance) {
            this._instance = new Clerk();
        }
        return this._instance;
    }
    logError(error, strict = false) {
        const logLevel = strict ? 'error' : 'warn';
        backend_core_1.Logger[logLevel](error.message);
        if (error instanceof backend_core_1.ClerkAPIResponseError) {
            (error.errors || []).forEach(({ message, longMessage }) => backend_core_1.Logger[logLevel](longMessage || message));
        }
    }
    authenticate(options) {
        const { onError, authorizedParties, jwtKey, strict } = options;
        async function doAuthenticate(req, res, next) {
            try {
                const cookies = new cookies_1.default(req, res);
                const cookieToken = cookies.get('__session');
                const headerToken = req.headers.authorization?.replace('Bearer ', '');
                const { status, interstitial, sessionClaims, errorReason } = await this.base.getAuthState({
                    cookieToken,
                    headerToken,
                    clientUat: cookies.get('__client_uat'),
                    origin: req.headers.origin,
                    host: req.headers.host,
                    forwardedPort: req.headers['x-forwarded-port'],
                    forwardedHost: req.headers['x-forwarded-host'],
                    referrer: req.headers.referer,
                    userAgent: req.headers['user-agent'],
                    authorizedParties,
                    jwtKey: jwtKey || this.jwtKey,
                    fetchInterstitial: () => this.fetchInterstitial(),
                });
                errorReason && res.setHeader('Auth-Result', errorReason);
                if (status === backend_core_1.AuthStatus.SignedOut) {
                    throw new Error('Unauthenticated');
                }
                if (status === backend_core_1.AuthStatus.SignedIn) {
                    // @ts-expect-error
                    req.auth = {
                        sessionId: sessionClaims?.sid,
                        userId: sessionClaims?.sub,
                        getToken: (0, backend_core_1.createGetToken)({
                            headerToken,
                            cookieToken,
                            sessionId: sessionClaims?.sid,
                            fetcher: (...args) => this.sessions.getToken(...args),
                        }),
                        claims: sessionClaims,
                    };
                    return next();
                }
                res.writeHead(401, { 'Content-Type': 'text/html' });
                res.write(interstitial);
                res.end();
            }
            catch (error) {
                // Auth object will be set to the signed out auth state
                // @ts-expect-error
                req.auth = {
                    userId: null,
                    sessionId: null,
                    getToken: (0, backend_core_1.createSignedOutState)().getToken,
                    claims: null,
                };
                this.logError(error, strict);
                const err = onError ? await onError(error) : error;
                // If strict, err will be returned to the Express-like `next` callback to signify an error should halt the request chain
                if (strict) {
                    next(err);
                }
                else {
                    next();
                }
            }
        }
        return doAuthenticate.bind(this);
    }
    // Connect/Express middlewares
    expressWithAuth(options = {}) {
        return this.authenticate({ strict: false, ...options });
    }
    expressRequireAuth(options = {}) {
        return this.authenticate({ strict: true, ...options });
    }
}
exports.default = Clerk;
//# sourceMappingURL=Clerk.js.map